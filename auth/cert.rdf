
<!-- Processed by Id: cwm.py,v 1.197 2007/12/13 15:38:39 syosi Exp -->
<!--     using base file:///Users/hjs/Programming/w3.org/WWW/ns/auth/cert.n3-->


<rdf:RDF xmlns="http://www.w3.org/2000/01/rdf-schema#"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:foaf="http://xmlns.com/foaf/0.1/"
    xmlns:owl="http://www.w3.org/2002/07/owl#"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
    xmlns:vs="http://www.w3.org/2003/06/sw-vocab-status/ns#">

    <owl:Ontology rdf:about="cert">
        <dc:created rdf:datatype="http://www.w3.org/2001/XMLSchema#date">2008-11-13</dc:created>
        <comment>
   Ontology for Certificates and crypto stuff.
   This is in development. 
   Some other ontologies to look at:
     * http://www.w3.org/2000/10/swap/crypto
        + has cwm builtins: http://www.w3.org/2000/10/swap/doc/Trust
        - a bit old perhaps. It imports daml+oil
        - would help to be more completely specified
        - uses literals as subjects a little liberally, which makes this a 
        bit difficult to work with frameworks that don't permit this
     * http://xmlns.com/wot/0.1/
        - limited very much to PGP (though on can map PGP to X509)
        - a little coarse grained, mixes up the PGP certificate with the PGP
          public key
     *
   Todo: 
     - add some classes and relations for DSA
     - should this all be in one file? Or should this be cut up a little? Say one file for the general CERT ontology, and then files for RSA, DSA, PGP, etc... Or perhaps it does not really matter?
     - expand more on the certification side of things
     - verify this by security experts
     - add more todos
     - owl2 has some constructs for combined inverse functional properties. 
       This may be useful to use in defining an RSA key which is identified
       by two numbers.
     - when more stable create rdf/xml version
     - also create html version of the spec by using this as a template.
     - should comments such as this be in html?
   </comment>
        <seeAlso rdf:resource="X509Uml.svg"/>
        <seeAlso rdf:resource="rsa"/>
        <seeAlso rdf:resource="http://lists.foaf-project.org/mailman/listinfo/foaf-protocols"/>
        <vs:term_status>unstable</vs:term_status>
        <foaf:maker rdf:resource="http://bblfish.net/people/henry/card#me"/>
    </owl:Ontology>

    <owl:Class rdf:about="cert#Certificate">
        <comment>A certificate is a Document that is signed.
    As explained here http://www.pgpi.org/doc/pgpintro/#p16
    'A digital certificate consists of three things:
        * A public key.
        * Certificate information. ('Identity' information about the  
          user, such as name, user ID, and so on.)
        * One or more digital signatures.'
    </comment>
        <subClassOf rdf:resource="http://xmlns.com/foaf/0.1/Document"/>
        <vs:term_status>unstable</vs:term_status>
    </owl:Class>

    <owl:Class rdf:about="cert#Integer">
        <comment> 
    The class of all integers, however large they be. 
    This should probably be defined in another ontology.
    Different representations for each can be defined via relations to string
    literals. 
    This is equivalent to the values of xsd:integer literals, except that we don't want to be locked into having to use a particular literal notation. Some of these integers are so long it is much better to express them in hexadecimal format.
    </comment>
        <vs:term_status>unstable</vs:term_status>
    </owl:Class>

    <owl:Class rdf:about="cert#Key">
        <comment>the class of keys</comment>
        <vs:term_status>unstable</vs:term_status>
    </owl:Class>

    <owl:Class rdf:about="cert#PGPCertificate">
        <comment>the class of PGP Certificates</comment>
        <subClassOf rdf:resource="cert#Certificate"/>
        <owl:equivalentClass rdf:resource="http://xmlns.com/wot/0.1/PubKey"/>
        <vs:term_status>unstable</vs:term_status>
    </owl:Class>

    <owl:Class rdf:about="cert#PrivateKey">
        <comment>Private Key</comment>
        <subClassOf rdf:resource="cert#Key"/>
    </owl:Class>

    <owl:Class rdf:about="cert#PublicKey">
        <comment>Public Key</comment>
        <subClassOf rdf:resource="cert#Key"/>
        <vs:term_status>unstable</vs:term_status>
    </owl:Class>

    <owl:Class rdf:about="cert#Signature">
        <comment>the class of signtatures</comment>
        <vs:term_status>unstable</vs:term_status>
    </owl:Class>

    <owl:Class rdf:about="cert#X509Certificate">
        <comment>the class of X509 Certificates</comment>
        <seeAlso rdf:resource="http://en.wikipedia.org/wiki/X509"/>
        <subClassOf rdf:resource="cert#Certificate"/>
        <vs:term_status>unstable</vs:term_status>
    </owl:Class>

    <owl:DatatypeProperty rdf:about="cert#decimal">
        <rdf:type rdf:resource="http://www.w3.org/2002/07/owl#InverseFunctionalProperty"/>
        <comment>
    The encoding of an integer in decimal format. Similar to xsd:integer,
    except that we relate an integer to its string representation.
    This should be part of another ontology of course.
    Could one use xsd:integer as such a relation, in which case this would be
    owl:sameAs xsd:integer
    </comment>
        <domain rdf:resource="cert#Integer"/>
        <range rdf:resource="http://www.w3.org/2001/XMLSchema#String"/>
        <vs:term_status>unstable</vs:term_status>
    </owl:DatatypeProperty>

    <owl:DatatypeProperty rdf:about="cert#hex">
        <rdf:type rdf:resource="http://www.w3.org/2002/07/owl#InverseFunctionalProperty"/>
        <comment xml:lang="en">
   An encoding of a positive integer (from 0 to infintity) as a hexadecimal string that makes it easy to read and/or fun to present on the web. 
   The purpose of this way of representing hexadecimals is to enable users to copy and paste hexadecimal notations as shown by most browsers, keychains or tools such as opensso, into their rdf representation of choice.  There are a wide variety of ways in which such strings can be presented. One finds the following 

  e1 dc d5 e1 00 8f 21 5e d5 cc 7c 7e c4 9c ad 86 
  64 aa dc 29 f2 8d d9 56 7f 31 b6 bd 1b fd b8 ee 
  51 0d 3c 84 59 a2 45 d2 13 59 2a 14 82 1a 0f 6e 
  d3 d1 4a 2d a9 4c 7e db 90 07 fc f1 8d a3 8e 38 
  25 21 0a 32 c1 95 31 3c ba 56 cc 17 45 87 e1 eb 
  fd 9f 0f 82 16 67 9f 67 fa 91 e4 0d 55 4e 52 c0 
  66 64 2f fe 98 8f ae f8 96 21 5e ea 38 9e 5c 4f 
  27 e2 48 ca ca f2 90 23 ad 99 4b cc 38 32 6d bf  

 Or the same as the above, with ':' instead of spaces. We can't guarantee that these are the only ways such tools will present hexadecimals, so we are very lax.
 The letters can be uppercase or lowercase, or mixed.  
 Some strings may start with initial 00's which would be very important if the number were in complement of 2 notation, where in some cases this could be the difference between a positive and a negative number, in particular if the number starts with one of [8-f].  But as we interpret this string as a hexadecimal number leading 00s are not important  (Complement of 2 notation and hexadecimal overlap for positive numbers)
 In order to make this fun, we allow any unicode characters in the string. A parser should 
  1. remove all non hexadecimal characters
  2. treat the resulting as a hexadecimal representation of a number
 This will allow people to make an ascii - better yet a UTF-8 - picture of their public key when publishing it on the web.
   </comment>
        <domain rdf:resource="cert#Integer"/>
        <label xml:lang="en">hexadecimal</label>
        <range rdf:resource="http://www.w3.org/2001/XMLSchema#String"/>
        <seeAlso rdf:resource="http://en.wikipedia.org/wiki/Hexadecimal"/>
        <vs:term_status>unstable</vs:term_status>
    </owl:DatatypeProperty>

    <rdf:Property rdf:about="cert#identity">
        <comment>
    the identity of the public key. This is the entity that knows the private key and so can decrypt messages encrypted with the public key, or encrypt messages that can be decrypted with the public key. It can be an Agent, or an idirect identifier of an agent such as a foaf:OnlineAccount .
    Should one specify the range as being the union of those two classes, or should one leave this open?
    </comment>
        <domain rdf:resource="cert#PublicKey"/>
        <vs:term_status>unstable</vs:term_status>
    </rdf:Property>

    <rdf:Property rdf:about="cert#public_key">
        <comment>
    relates the private key to the public key component, in a public/private
    key pair.
    </comment>
        <domain rdf:resource="cert#PrivateKey"/>
        <range rdf:resource="cert#PublicKey"/>
        <vs:term_status>unstable</vs:term_status>
    </rdf:Property>
</rdf:RDF>
